# MySQL事务

​		事务指逻辑上的一组操作，组成这组操作的各个单元，要不全部成功，要不全部不成功。 MySQL事务有四个特性，分别是原子性，持久性，隔离性，一致性，即ACID。原子性指的是整个事务是不可分割的最小单位，整个事务要么全部执行成功，要么全部执行失败。持久性指的是事务一旦提交，就是永久性的影响，不会因为宕机等故障导致数据丢失，隔离性指的是每个事务都感觉不到系统有其他事务在并发地执行，而一致性指的是事务将数据库从一种状态转变为另一种状态，在事务的前后，数据库的完整性约束不会被破坏。

​		MySQL事务支持是在引擎层实现，而非服务层，所以不同引擎对事务的实现方式各不相同，有些引擎比如MyIsam不支持事务。

​		对于InnoDB引擎来说，原子性是使用undolog实现的。undolog，即回滚日志，用于记录数据被修改前地信息，undolog主要记录数据的逻辑变化。undolog有两个作用，一个是提供回滚来实现原子性，另一个是实现多版本控制，MVCC。在数据被修改的时候，比如delete,undolog中会记录一条对应的insert记录，反之亦然。当执行回滚时，就可以从undolog中的逻辑记录读取到相应的内容并进行回滚。在MVCC中，也是通过undolog实现的，当读取的某一行被其他事务锁定时，它可以从undolog中分析出该行记录以前的数据时什么。

​		undolog 是用段（segment)的放的来记录的，每个undo操作在记录的时候占用一个undo log segment。在事务提交的时候，innodb不会立即删除undolog,因为后续还可能用到，比如在隔离级别为repeadable read时，事务读取的都是开启事务时最新提交的版本，只要该事务不结束，该行版本就不能删除。但是在事务提交的时候，会将该事务对应的undo log放入到删除列表中，后续通过purge线程删除。还会判断undo log分配的页是否可以重用，如果可以会分配给后面来的事务，避免每个独立的事务分配独立的undolog而浪费空间。

​			通过undo log记录delete和update操作的结果发现：(insert操作无需分析，就是插入行而已)

- delete操作实际上不会直接删除，而是将delete对象打上delete flag，标记为删除，最终的删除操作是purge线程完成的。
- update分为两种情况：update的列是否是主键列。
  - 如果不是主键列，在undo log中直接反向记录是如何update的。即update是直接进行的。
  - 如果是主键列，update分两部执行：先删除该行，再插入一行目标行。

值得一提的时，undolog也需要持久化，产生redolog。

​		持久性使用redolog来实现。redolog是重做日志，通常是物理日志，记录的是数据页的物理修改，而不是某一行操作的逻辑修改。redolog包括两个部分，一是内存中的日志缓冲log buffer，这部分日志是易失性的，另一个是磁盘上的重做日志redolog file，该部分是持久的。InnoDB通过force log at commit 机制实现事务的持久性，即在事务提交的时候，必须先将事务的所有事务写入到磁盘上的redolog file进行持久化。因为如果先写数据库再写日志，如果出现宕机，数据的操作将是不可恢复的。由于mysql进程mysqld在用户空间，log buffer在用户空间的内存中，将数据从内存写入磁盘中间需要经过操作系统内核空间的os buffer,然后调用一次系统的fsync()函数，调用这个函数需要cpu从用户态转换为内核态，经常处理开销较大。

​		所以MySQL支持用户自定义在用户提交时如何将redolog buffer刷入到redolog file中，利用变量innodb_flush_log_at_trx_commit的值决定。这个变量有三个值0，1，2。代表了3中方法。

- 当设置为1的时候，事务***每次***提交都会将log buffer中的日志写入os buffer并调用fsync()刷到log file中。这种方式不会丢失任何数据，但是IO的性能较差。
- 当设置为0的时候，事务提交时不会写入，而是***每秒* **写入os buffer并调用fsync()写入到log file中。当系统崩溃，会丢失1秒钟的数据。
- 当设置为2的时候，***每次***提交都仅写入到os buffer，然后是***每秒***调用fsync()将os buffer中的日志写入到log file。

​        SQL标准中定义了4个隔离级别，分别是未提交读，提交读，可重复读和可串行化。隔离级别依次逐渐提高。在未提交读的级别中，在一个事务中对数据进行修改，即使这个事务还没有提交，其他事务也可以看到这个修改，这也被称为脏读。（这个事务修改数据）

​        在提交读中，只允许读取已经提交的数据。但是如果在一个事务内对数据进行两次读取，这时候其他事务有可能修改了这个数据并提交。这个事务两次读取的数据是不一样的，这个级别又被成为不可重复读。这也是大多数数据库的默认级别。（其他事务修改数据）

​        在可重复读中，保证了在同一个事务中多次读取同样的记录结果是一致的。但是当一个事务在读取某一个范围的数据时，其他事务在该范围内插入了一条新的记录，这个事务再进行读取时会产生幻行，也就是幻读现象。InnoDB引擎默认的隔离级别就是可重复读，并且通过MVCC解决了幻读现象。

​        可串行化是最高的隔离级别，它通过强制事务串行执行，避免了幻读现象。但同时可串行化会在读取的每一行数据都加上锁，可能导致大量的超时和锁争用问题。

​        隔离性主要使用加锁和MVCC（多版本并发控制）实现。MyISAM引擎只支持表级锁，InnoDB行级锁表级锁都支持，默认情况下在允许使用行级锁地时候都会使用行级锁，表级锁只有两种简单的锁类型：

- 共享锁，允许一个事务去读一行，即读锁。
- 独占锁，允许一个事务更新或删除一行，即写锁。

行级锁支持更多的锁类型：

- 意向共享锁， 事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该**表**的IS锁。即获取低级别共享锁的同时，在高级别上也获取特殊的共享锁 。
- 意向独占锁， 事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该**表**的IX锁。即 获取低级别独占锁的同时，在高级别上也获取特殊的独占锁 。

低级别锁表示的是行锁或页锁，意向锁可能是多条记录组成的范围锁，也可能直接就是表意向锁。 

意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。 

InnoDB有三种锁算法：

- record lock （记录锁） ：即行锁,它的行锁锁定的是key,基于唯一性索引键列来锁定,如果没有唯一性索引键列，则会自动在隐式列上创建索引并完成锁定。
- gap lock （间隙锁） ：范围锁，但是不锁定行记录本身
- next-key lock：范围锁加行锁，即范围锁并锁定记录本身，gap lock + record lock。innodb对行的锁申请默认都是这种算法。如果有索引，则只锁定指定范围内的索引键值，如果没有索引，则自动创建索引并对整个表进行范围锁定。之所以锁定了表还称为范围锁定，是因为它实际上锁的不是表，而是把所有可能的区间都锁定了，从主键值的负无穷到正无穷的所有区间都锁定，等价于锁定了表。

有了锁我们就可以实现四种隔离级别，但由于加锁的开销比较大，InnoDB实际上是使用锁+MVCC的方式实现的隔离级别。

​        在InnoDB中，给每行增加两个隐藏字段来实现MVCC，一个用来记录数据行的创建时间，另一个用来记录行的过期时间（删除时间）。在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 

默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：

- SELECT：读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。
- INSERT：将当前事务的版本号保存至行的创建版本号
- UPDATE：新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号
- DELETE：将当前事务的版本号保存至行的删除版本号

​         普通的SELECT用的是一致性读不加锁。而对于锁定读、UPDATE和DELETE，则需要加锁，至于加什么锁视情况而定。如果你使用了唯一索引作为检索条件，那么只需锁定索引记录，用记录锁即可；如果没有，或者用到了索引范围扫描，那么将会使用间隙锁或者next-key锁以此来阻塞其它会话向这个范围内的间隙插入数据。 

所以，InnoDB通过MVCC实现可重复读，并使用间隙锁解决了幻读的问题。

通过保证数据库原子性、持久性、一致性的实现，数据库事务的一致性得以保证。





# MYSQL索引



# Redis数据结构



# Redis其他



# HashMap



# ConcurrentHashMap



# Spring Ioc



# Spring AOP



# JVM垃圾回收



# JVM类加载



# 线程池



# 同步器



# synchronized



# volatile



# ThreadLaaocal



# Linux性能优化命令



# Linux进程线程调度



# Linux epoll（BIO NIO AIO）



# TCP/UDP





# HTTP
